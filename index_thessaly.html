<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Thessalia Cartography ‚Äì Interactive Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<style>
  body { margin: 0; padding: 0; font-family: Arial, Helvetica, sans-serif; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }

  #styleSelector {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 6px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.25);
  }

  #controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 10px;
    font-size: 13px;
    border-radius: 6px;
    width: 300px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  }

  .layer-controls { margin-top:6px; padding:8px; background:#fafafa; border-radius:4px; display:none; }
  .layer-controls label { display:block; font-size:12px; margin-top:6px; }
  .layer-controls input[type="range"], .layer-controls select { width:100%; margin-top:4px; }

  #legend {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 6;
    background: white;
    padding: 18px;
    font-size: 13px;
    border-radius: 6px;
    max-width: 360px;
    max-height: 85vh;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    display: none;
    resize: both;
    overflow: auto;
    min-width: 200px;
    min-height: 100px;
  }

  .legend-header { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #333; }
  .legend-map-title { font-size: 15px; font-weight: 700; color: #000; margin-bottom: 10px; line-height: 1.4; text-align: center; }
  .legend-author { font-size: 10px; color: #555; line-height: 1.4; text-align: left; }
  .legend-author strong { font-weight: 700; }

  .legend-row { display:flex; align-items:center; margin-bottom:8px; }
  .legend-color { width:20px; height:20px; margin-right:8px; border-radius:3px; flex:none; border: 1px solid rgba(0,0,0,0.12); }
  .legend-line { width:40px; height:14px; margin-right:8px; flex:none; }
  .legend-title { font-weight:700; margin-bottom:8px; display:block; }
  .control-value { font-weight:700; margin-left:6px; color:#333; }
  hr { border: none; border-top: 1px solid #eee; margin:8px 0; }
</style>
</head>

<body>

<div id="styleSelector">
  <select id="basemapSelect">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark</option>
  </select>
</div>

<div id="controls">
  <strong>Layers</strong><br><br>

  <input type="checkbox" id="popdensToggle"> <strong>Population Density (Choropleth Map)</strong><br>
  <div class="layer-controls" id="popdensControls">
    <label>Classification method:
      <select id="classificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
        <option value="custom">Custom intervals</option>
      </select>
    </label>
    <label id="numClassesLabel">Number of classes:
      <select id="numClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="popdensOpacityLabel" class="control-value">60%</span>
      <input type="range" id="popdensOpacity" min="0" max="100" value="60">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      Outline is added automatically for visibility.
    </small>
  </div>
  <hr>

  <!-- ‚úÖ FIXED: Dasymmetric layer is categorical (COVER/COVER_CODE), not numeric DENS_COVER -->
  <input type="checkbox" id="denscoverToggle"> <strong>Land cover zones (Dasymetric base)</strong><br>
  <div class="layer-controls" id="denscoverControls">
    <label>Opacity: <span id="denscoverOpacityLabel" class="control-value">60%</span>
      <input type="range" id="denscoverOpacity" min="0" max="100" value="60">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      Styled by <code>COVER_CODE</code> (categories). If you later create a numeric <code>DENS_COVER</code>, tell me and we revert to classification.
    </small>
  </div>
  <hr>

  <input type="checkbox" id="poipopToggle"> <strong>Population (Proportional symbols)</strong><br>
  <div class="layer-controls" id="poipopControls">
    <label>Maximum circle radius (px): <span id="maxRadiusLabel" class="control-value">100</span>
      <input type="range" id="maxRadius" min="20" max="200" value="100">
    </label>
    <label>Opacity (circles): <span id="poipopOpacityLabel" class="control-value">25%</span>
      <input type="range" id="poipopOpacity" min="0" max="100" value="25">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      <strong>Note:</strong> Flannery scaling is used for perceptual equality.
    </small>
  </div>
  <hr>

  <input type="checkbox" id="contoursToggle"> <strong>Population dynamic (Isopleths map)</strong><br>
  <div class="layer-controls" id="contoursControls">
    <label>Opacity (contours): <span id="contoursOpacityLabel" class="control-value">80%</span>
      <input type="range" id="contoursOpacity" min="0" max="100" value="80">
    </label>
  </div>
  <hr>

  <input type="checkbox" id="dotsToggle"> <strong>Population (Dot map)</strong><br>
  <div class="layer-controls" id="dotsControls">
    <label>Dot size (px): <span id="dotSizeLabel" class="control-value">1.9</span>
      <input type="range" id="dotSize" min="0.5" max="6" step="0.1" value="1.9">
    </label>
    <label>Opacity (dots): <span id="dotsOpacityLabel" class="control-value">100%</span>
      <input type="range" id="dotsOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <input type="checkbox" id="boundariesToggle"> <strong>Municipal boundaries</strong><br>
  <div class="layer-controls" id="boundariesControls">
    <label>Opacity (boundaries): <span id="boundariesOpacityLabel" class="control-value">100%</span>
      <input type="range" id="boundariesOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <div style="font-size:12px;color:#555">
    <strong>Data notes</strong><br>
    - GeoJSONs in <code>data/</code><br>
    - Choropleth field: <code>POPDENS</code><br>
    - Proportional symbols field: <code>POPMUN</code><br>
    - Dasymetric base fields: <code>COVER</code>, <code>COVER_CODE</code><br>
    - Contours use <code>ID</code>
  </div>
</div>

<div id="legend"></div>
<div id="map"></div>

<script>
// ============================================================
// 1. MAP INITIALIZATION
// ============================================================
const map = new maplibregl.Map({
  container: 'map',
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  center: [22.45, 39.45], // Thessaly (approx center)
  zoom: 8.2
});

function addBaseControls() {
  // Avoid duplicates when switching style
  const existing = map._controls || [];
  // MapLibre doesn't provide easy getter; safe re-add is fine in most cases, but we try to keep it simple:
  map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right');
  map.addControl(new maplibregl.ScaleControl({ maxWidth: 120, unit: 'metric' }), 'bottom-left');
}
addBaseControls();

// ============================================================
// 2. DATA CONFIGURATION
// ============================================================
const layerDefinitions = {
  popdens: {
    sourceId: 'popdens-src',
    layerId: 'popdens-layer',
    outlineLayerId: 'popdens-outline',
    url: 'data/dens.geojson',
    dataField: 'POPDENS'
  },
  // ‚úÖ FIXED HERE
  denscover: {
    sourceId: 'denscover-src',
    layerId: 'denscover-layer',
    outlineLayerId: 'denscover-outline',
    url: 'data/dasimetriko.geojson',
    dataField: 'COVER_CODE',    // ‚úÖ was DENS_COVER
    labelField: 'COVER'         // ‚úÖ for legend labels (if exists)
  },
  poipop: {
    sourceId: 'poipop-src',
    layerId: 'poipop-layer',
    url: 'data/dimoipop91_21.geojson',
    dataField: 'POPMUN',
    maxValueApprox: 150000
  },
  contours: {
    sourceId: 'contours-src',
    layerId: 'contours-layer',
    url: 'data/kur_deut.geojson'
  },
  dots: {
    sourceId: 'dots-src',
    layerId: 'dots-layer',
    url: 'data/dot500pop.geojson'
  },
  boundaries: {
    sourceId: 'boundaries-src',
    layerId: 'boundaries-layer',
    url: 'data/dimoi_oria.geojson'
  }
};

let popdensData = null;
let denscoverData = null;

const enabledLayers = {
  popdens: false,
  denscover: false,
  poipop: false,
  contours: false,
  dots: false,
  boundaries: false
};

// ============================================================
// 3. COLOR SCHEMES (choropleth)
// ============================================================
const colorSchemes = {
  3: ['#ffcccc', '#ff6666', '#990000'],
  4: ['#ffcccc', '#ff9999', '#cc0000', '#990000'],
  5: ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000'],
  6: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#cc0000', '#990000'],
  7: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#ff0000', '#cc0000', '#990000']
};

const customBreaks = [30, 75, 150, 300, 600];
const customColors = ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000', '#660000'];

// ============================================================
// 4. CLASSIFICATION FUNCTIONS (choropleth only)
// ============================================================
function equalIntervalBreaks(sorted, n) {
  const min = sorted[0];
  const max = sorted[sorted.length - 1];
  if (min === max) return [max];
  const step = (max - min) / n;
  const breaks = [];
  for (let i = 1; i < n; i++) breaks.push(min + step * i);
  return breaks.map(b => Number(b.toFixed(2)));
}
function quantileBreaks(sorted, n) {
  const breaks = [];
  for (let i = 1; i < n; i++) {
    const idx = Math.floor((sorted.length * i) / n);
    breaks.push(sorted[Math.min(idx, sorted.length - 1)]);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}
function jenksBreaks(sorted, numClasses) {
  const n = sorted.length;
  const mat1 = Array.from({ length: n + 1 }, () => Array(numClasses + 1).fill(0));
  const mat2 = Array.from({ length: n + 1 }, () => Array(numClasses + 1).fill(0));

  for (let i = 1; i <= numClasses; i++) {
    mat1[1][i] = 1;
    mat2[1][i] = 0;
    for (let j = 2; j <= n; j++) mat2[j][i] = Infinity;
  }

  for (let l = 2; l <= n; l++) {
    let s1 = 0, s2 = 0, w = 0;
    for (let m = 1; m <= l; m++) {
      const i3 = l - m + 1;
      const val = sorted[i3 - 1];
      s2 += val * val;
      s1 += val;
      w++;
      const v = s2 - (s1 * s1) / w;
      const i4 = i3 - 1;
      if (i4 !== 0) {
        for (let j = 2; j <= numClasses; j++) {
          if (mat2[l][j] >= (v + mat2[i4][j - 1])) {
            mat1[l][j] = i3;
            mat2[l][j] = v + mat2[i4][j - 1];
          }
        }
      }
    }
    mat1[l][1] = 1;
    mat2[l][1] = mat2[l - 1][1] + (sorted[l - 1] - sorted[0]) * (sorted[l - 1] - sorted[0]);
  }

  const breaks = [];
  let k = n;
  for (let j = numClasses; j >= 2; j--) {
    const id = mat1[k][j] - 1;
    breaks.push(sorted[id]);
    k = mat1[k][j] - 1;
  }
  return breaks.reverse().map(b => Number(b.toFixed(2)));
}
function calculateBreaks(values, numClasses, method, customBreaksArray) {
  const sorted = values.filter(v => v != null && !isNaN(v)).sort((a, b) => a - b);
  if (sorted.length === 0) return [];
  if (method === 'equal') return equalIntervalBreaks(sorted, numClasses);
  if (method === 'quantile') return quantileBreaks(sorted, numClasses);
  if (method === 'natural') return jenksBreaks(sorted, numClasses);
  if (method === 'custom') return customBreaksArray;
  return equalIntervalBreaks(sorted, numClasses);
}
function createStepExpression(breaks, colors, field) {
  const expr = ['step', ['get', field], colors[0]];
  for (let i = 0; i < breaks.length; i++) {
    expr.push(breaks[i]);
    expr.push(colors[i + 1] || colors[colors.length - 1]);
  }
  return expr;
}
function ensureSource(id, urlOrGeojson) {
  if (!map.getSource(id)) {
    map.addSource(id, { type: 'geojson', data: urlOrGeojson });
  } else {
    if (typeof urlOrGeojson === 'object') map.getSource(id).setData(urlOrGeojson);
  }
}

// ============================================================
// 5. LAYER LOADING
// ============================================================

// --------- Choropleth (numeric POPDENS) ----------
function applyPopDensClassification() {
  if (!popdensData) return;

  const method = document.getElementById('classificationMethod').value;
  const nclasses = parseInt(document.getElementById('numClasses').value, 10);

  let colors, breaks;

  if (method === 'custom') {
    breaks = customBreaks;
    colors = customColors;
  } else {
    colors = colorSchemes[nclasses] || colorSchemes[5];
    const values = popdensData.features.map(f => parseFloat(f.properties[layerDefinitions.popdens.dataField]));
    breaks = calculateBreaks(values, nclasses, method, null);
  }

  const expr = createStepExpression(breaks, colors, layerDefinitions.popdens.dataField);
  ensureSource(layerDefinitions.popdens.sourceId, popdensData);

  // fill
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.popdens.layerId,
      type: 'fill',
      source: layerDefinitions.popdens.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('popdensOpacity').value, 10) / 100
      }
    });
  }

  // outline for visibility
  if (!map.getLayer(layerDefinitions.popdens.outlineLayerId)) {
    map.addLayer({
      id: layerDefinitions.popdens.outlineLayerId,
      type: 'line',
      source: layerDefinitions.popdens.sourceId,
      paint: {
        'line-color': 'rgba(255,255,255,0.35)',
        'line-width': 0.6
      }
    });
  }

  layerDefinitions.popdens.breaks = breaks;
  layerDefinitions.popdens.colors = colors;
  enabledLayers.popdens = true;
  document.getElementById('popdensControls').style.display = 'block';
  updateLegend();
}
function loadPopDensLayer() {
  fetch(layerDefinitions.popdens.url)
    .then(r => r.json())
    .then(gj => { popdensData = gj; applyPopDensClassification(); })
    .catch(err => { console.error(err); alert('Error loading dens.geojson (POPDENS).'); });
}

// --------- Dasymetric base (categorical COVER_CODE/COVER) ----------
const denscoverPalette = [
  '#fef0d9','#fdcc8a','#fc8d59','#e34a33','#b30000',
  '#d9f0a3','#addd8e','#78c679','#41ab5d','#006837',
  '#deebf7','#9ecae1','#6baed6','#3182bd','#08519c',
  '#f2f0f7','#cbc9e2','#9e9ac8','#756bb1','#54278f'
];

function buildDensCoverColorMap(geojson) {
  // Unique category codes
  const fieldCode = layerDefinitions.denscover.dataField;   // COVER_CODE
  const fieldLabel = layerDefinitions.denscover.labelField; // COVER (optional)

  const mapByCode = new Map(); // code -> {label, color}
  for (const f of geojson.features) {
    const code = f?.properties?.[fieldCode];
    if (code === undefined || code === null) continue;
    if (!mapByCode.has(code)) {
      const label = (fieldLabel && f.properties[fieldLabel] != null) ? String(f.properties[fieldLabel]) : String(code);
      mapByCode.set(code, { label, color: null });
    }
  }

  const codes = Array.from(mapByCode.keys()).sort((a,b) => {
    const na = Number(a), nb = Number(b);
    if (!isNaN(na) && !isNaN(nb)) return na - nb;
    return String(a).localeCompare(String(b));
  });

  codes.forEach((code, i) => {
    const entry = mapByCode.get(code);
    entry.color = denscoverPalette[i % denscoverPalette.length];
  });

  return { mapByCode, codes };
}

function applyDensCoverCategorical() {
  if (!denscoverData) return;

  const { mapByCode, codes } = buildDensCoverColorMap(denscoverData);

  // MapLibre "match" expression: match(get(COVER_CODE), code1,color1, code2,color2, default)
  const expr = ['match', ['get', layerDefinitions.denscover.dataField]];
  for (const code of codes) {
    const { color } = mapByCode.get(code);
    // Keep type: if numeric codes, pass number; if string, pass string
    const num = Number(code);
    const key = (!isNaN(num) && String(num) === String(code)) ? num : code;
    expr.push(key, color);
  }
  expr.push('#cccccc'); // default

  ensureSource(layerDefinitions.denscover.sourceId, denscoverData);

  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.denscover.layerId,
      type: 'fill',
      source: layerDefinitions.denscover.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('denscoverOpacity').value, 10) / 100
      }
    });
  }

  // outline for visibility
  if (!map.getLayer(layerDefinitions.denscover.outlineLayerId)) {
    map.addLayer({
      id: layerDefinitions.denscover.outlineLayerId,
      type: 'line',
      source: layerDefinitions.denscover.sourceId,
      paint: {
        'line-color': 'rgba(255,255,255,0.25)',
        'line-width': 0.5
      }
    });
  }

  // store for legend
  layerDefinitions.denscover.isCategorical = true;
  layerDefinitions.denscover.categoryMap = mapByCode;
  layerDefinitions.denscover.categoryCodes = codes;

  enabledLayers.denscover = true;
  document.getElementById('denscoverControls').style.display = 'block';
  updateLegend();
}

function loadDensCoverLayer() {
  fetch(layerDefinitions.denscover.url)
    .then(r => r.json())
    .then(gj => { denscoverData = gj; applyDensCoverCategorical(); })
    .catch(err => { console.error(err); alert('Error loading dasimetriko.geojson.'); });
}

// --------- Proportional symbols ----------
function loadPoipopLayer() {
  const def = layerDefinitions.poipop;
  fetch(def.url)
    .then(r => r.json())
    .then(geojson => {
      geojson.features.sort((a, b) => {
        const valA = parseFloat(a.properties[def.dataField]) || 0;
        const valB = parseFloat(b.properties[def.dataField]) || 0;
        return valB - valA;
      });

      ensureSource(def.sourceId, geojson);

      const maxR = parseInt(document.getElementById('maxRadius').value, 10);
      const vL = def.maxValueApprox || 150000;
      const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];

      if (!map.getLayer(def.layerId)) {
        map.addLayer({
          id: def.layerId,
          type: 'circle',
          source: def.sourceId,
          paint: {
            'circle-color': 'rgba(255,0,0,0.25)',
            'circle-radius': radiusExpr,
            'circle-opacity': parseInt(document.getElementById('poipopOpacity').value, 10) / 100,
            'circle-stroke-color': 'red',
            'circle-stroke-width': 0.8
          }
        });
      } else {
        map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
        map.setPaintProperty(def.layerId, 'circle-opacity', parseInt(document.getElementById('poipopOpacity').value, 10) / 100);
      }

      enabledLayers.poipop = true;
      document.getElementById('poipopControls').style.display = 'block';
      updateLegend();
    })
    .catch(err => { console.error(err); alert('Error loading dimoipop91_21.geojson (POPMUN).'); });
}
function updatePoipopRadius() {
  const def = layerDefinitions.poipop;
  if (!map.getLayer(def.layerId)) return;
  const maxR = parseInt(document.getElementById('maxRadius').value, 10);
  const vL = def.maxValueApprox || 150000;
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];
  map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
  updateLegend();
}

// --------- Contours ----------
function loadContoursLayer() {
  const def = layerDefinitions.contours;
  ensureSource(def.sourceId, def.url);

  const widthExpr = ['case', ['==', ['get', 'ID'], 1], 3, 1.2];
  const color = '#8B0000';

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': color,
        'line-width': widthExpr,
        'line-opacity': parseInt(document.getElementById('contoursOpacity').value, 10) / 100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-width', widthExpr);
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('contoursOpacity').value, 10) / 100);
  }

  enabledLayers.contours = true;
  document.getElementById('contoursControls').style.display = 'block';
  updateLegend();
}

// --------- Dots ----------
function loadDotsLayer() {
  const def = layerDefinitions.dots;
  ensureSource(def.sourceId, def.url);

  const dotSize = parseFloat(document.getElementById('dotSize').value);
  const opacity = parseInt(document.getElementById('dotsOpacity').value, 10) / 100;

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': '#ff0000',
        'circle-radius': dotSize,
        'circle-opacity': opacity
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', dotSize);
    map.setPaintProperty(def.layerId, 'circle-opacity', opacity);
  }

  enabledLayers.dots = true;
  document.getElementById('dotsControls').style.display = 'block';
  updateLegend();
}

// --------- Boundaries ----------
function loadBoundariesLayer() {
  const def = layerDefinitions.boundaries;
  ensureSource(def.sourceId, def.url);

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': '#bbbbbb',
        'line-width': 1,
        'line-opacity': parseInt(document.getElementById('boundariesOpacity').value, 10) / 100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('boundariesOpacity').value, 10) / 100);
  }

  enabledLayers.boundaries = true;
  document.getElementById('boundariesControls').style.display = 'block';
  updateLegend();
}

// --------- Remove ----------
function removeLayer(name) {
  const def = layerDefinitions[name];
  if (map.getLayer(def.layerId)) map.removeLayer(def.layerId);
  if (def.outlineLayerId && map.getLayer(def.outlineLayerId)) map.removeLayer(def.outlineLayerId);
  if (map.getSource(def.sourceId)) map.removeSource(def.sourceId);
  enabledLayers[name] = false;
  const c = document.getElementById(name + 'Controls');
  if (c) c.style.display = 'none';
  updateLegend();
}

// ============================================================
// 6. LEGEND
// ============================================================
function updateLegend() {
  const legend = document.getElementById('legend');
  let html = '';

  html += `
    <div class="legend-header">
      <div class="legend-map-title">THESSALIA POPULATION (Census 2021)</div>
      <div class="legend-author">
        <strong>Data source:</strong> Hellenic Statistical Authority (ELSTAT) ‚Äì Census 2021<br>
        <strong>Produced by:</strong> Œ£Œ§ŒëŒúŒëŒ§ŒïŒõŒë ŒôŒ¶ŒôŒìŒïŒùŒïŒôŒë Œ†ŒüŒ•ŒõŒôŒëŒ£Œó<br>
        <strong>Student ID:</strong> rs21636<br>
        National Technical University of Athens (NTUA)<br>
        School of Rural, Surveying & Geoinformatics Engineering<br>
        Cartography Laboratory<br>
        Thematic Cartography, Academic Year 2025-2026
      </div>
    </div>
  `;

  // Choropleth legend
  if (enabledLayers.popdens && layerDefinitions.popdens.breaks) {
    const breaks = layerDefinitions.popdens.breaks;
    const colors = layerDefinitions.popdens.colors;
    html += `<div class="legend-title">Choropleth map (people / km¬≤)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    for (let i = 0; i < breaks.length - 1; i++) {
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i + 1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i + 1]}</div></div>`;
    }
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length - 1]}"></div><div>&gt; ${breaks[breaks.length - 1]}</div></div>`;
    html += '<hr>';
  }

  // ‚úÖ Dasymetric base legend (categorical)
  if (enabledLayers.denscover && layerDefinitions.denscover.isCategorical && layerDefinitions.denscover.categoryMap) {
    html += `<div class="legend-title">Dasymetric base (land cover categories)</div>`;
    const codes = layerDefinitions.denscover.categoryCodes || [];
    const cmap = layerDefinitions.denscover.categoryMap;

    // show up to 12 categories to keep legend readable (adjust if you want)
    const maxShow = 12;
    const showCodes = codes.slice(0, maxShow);

    for (const code of showCodes) {
      const { label, color } = cmap.get(code);
      html += `<div class="legend-row"><div class="legend-color" style="background:${color}"></div><div>${label} <span style="color:#888">(${code})</span></div></div>`;
    }
    if (codes.length > maxShow) {
      html += `<div style="font-size:11px;color:#777;margin-top:6px;">+ ${codes.length - maxShow} more categories‚Ä¶</div>`;
    }
    html += '<hr>';
  }

  // Proportional symbols legend
  if (enabledLayers.poipop) {
    const maxR = parseInt(document.getElementById('maxRadius').value, 10);
    const maxVal = layerDefinitions.poipop.maxValueApprox || 150000;

    const value1 = 500;
    const value2 = 8000;
    const value3 = 40000;
    const value4 = 80000;

    const label1 = "500";
    const label2 = "8,000";
    const label3 = "40,000";
    const label4 = "80,000";

    const r1 = Math.pow(value1 / maxVal, 0.57) * maxR;
    const r2 = Math.pow(value2 / maxVal, 0.57) * maxR;
    const r3 = Math.pow(value3 / maxVal, 0.57) * maxR;
    const r4 = Math.pow(value4 / maxVal, 0.57) * maxR;

    const svgWidth = r4 * 2 + 60;
    const svgHeight = r4 * 2 + 30;
    const centerX = svgWidth / 2;
    const bottomY = svgHeight - 10;

    const cy1 = bottomY - r1;
    const cy2 = bottomY - r2;
    const cy3 = bottomY - r3;
    const cy4 = bottomY - r4;

    html += `<div class="legend-title">Population (indicative values)</div>`;
    html += `<div style="text-align:center"><svg width="${svgWidth}" height="${svgHeight}">`;

    html += `<circle cx="${centerX}" cy="${cy4}" r="${r4}" fill="none" stroke="red" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy4 - r4 - 5}" text-anchor="middle" font-size="11" fill="#333">${label4}</text>`;

    html += `<circle cx="${centerX}" cy="${cy3}" r="${r3}" fill="none" stroke="red" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy3 - r3 - 5}" text-anchor="middle" font-size="11" fill="#333">${label3}</text>`;

    html += `<circle cx="${centerX}" cy="${cy2}" r="${r2}" fill="none" stroke="red" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy2 - r2 - 5}" text-anchor="middle" font-size="11" fill="#333">${label2}</text>`;

    html += `<circle cx="${centerX}" cy="${cy1}" r="${r1}" fill="none" stroke="red" stroke-width="1.5"/>`;
    html += `<text x="${centerX}" y="${cy1 - r1 - 5}" text-anchor="middle" font-size="11" fill="#333">${label1}</text>`;

    html += `</svg></div><hr>`;
  }

  // Contours
  if (enabledLayers.contours) {
    html += `<div class="legend-title">Population dynamic (2M & 4M)</div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="3"/></svg><div>Primary (Id = 1)</div></div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="1.2"/></svg><div>Secondary (Id = 2)</div></div>`;
    html += '<hr>';
  }

  // Dots
  if (enabledLayers.dots) {
    html += `<div class="legend-title">Population density</div>`;
    html += `<div class="legend-row"><svg width="30" height="24"><circle cx="15" cy="12" r="${parseFloat(document.getElementById('dotSize').value)}" fill="#ff0000"/></svg><div>1 dot = 500 people</div></div>`;
    html += '<hr>';
  }

  // Boundaries
  if (enabledLayers.boundaries) {
    html += `<div class="legend-row"><svg width="40" height="18"><line x1="0" y1="9" x2="40" y2="9" stroke="#bbbbbb" stroke-width="1"/></svg> <div> Municipal boundaries</div></div>`;
  }

  if (html.length) {
    html += `<div style="text-align:right;font-size:10px;color:#999;margin-top:10px;">üí° Drag corner to resize</div>`;
    legend.innerHTML = html;
    legend.style.display = 'block';
  } else {
    legend.style.display = 'none';
  }
}

// ============================================================
// 7. EVENT LISTENERS
// ============================================================
function showHideControls() {
  Object.keys(enabledLayers).forEach(k => {
    const checkbox = document.getElementById(k + 'Toggle');
    const controls = document.getElementById(k + 'Controls');
    if (!controls) return;
    controls.style.display = checkbox.checked ? 'block' : 'none';
  });
}

// Choropleth
document.getElementById('popdensToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadPopDensLayer();
  else removeLayer('popdens');
});
document.getElementById('classificationMethod').addEventListener('change', () => {
  const method = document.getElementById('classificationMethod').value;
  const numClassesLabel = document.getElementById('numClassesLabel');
  const numClassesSelect = document.getElementById('numClasses');
  if (method === 'custom') { numClassesSelect.disabled = true; numClassesLabel.style.opacity = '0.5'; }
  else { numClassesSelect.disabled = false; numClassesLabel.style.opacity = '1'; }
  if (enabledLayers.popdens) applyPopDensClassification();
});
document.getElementById('numClasses').addEventListener('change', () => {
  if (enabledLayers.popdens) applyPopDensClassification();
});
document.getElementById('popdensOpacity').addEventListener('input', (e) => {
  document.getElementById('popdensOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-opacity', parseInt(e.target.value, 10) / 100);
  }
});

// ‚úÖ Dasymetric categorical
document.getElementById('denscoverToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadDensCoverLayer();
  else removeLayer('denscover');
});
document.getElementById('denscoverOpacity').addEventListener('input', (e) => {
  document.getElementById('denscoverOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-opacity', parseInt(e.target.value, 10) / 100);
  }
});

// Proportional
document.getElementById('poipopToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadPoipopLayer();
  else removeLayer('poipop');
});
document.getElementById('maxRadius').addEventListener('input', (e) => {
  document.getElementById('maxRadiusLabel').textContent = e.target.value;
  updatePoipopRadius();
});
document.getElementById('poipopOpacity').addEventListener('input', (e) => {
  document.getElementById('poipopOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.poipop.layerId)) {
    map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-opacity', parseInt(e.target.value, 10) / 100);
  }
});

// Contours
document.getElementById('contoursToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadContoursLayer();
  else removeLayer('contours');
});
document.getElementById('contoursOpacity').addEventListener('input', (e) => {
  document.getElementById('contoursOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.contours.layerId)) {
    map.setPaintProperty(layerDefinitions.contours.layerId, 'line-opacity', parseInt(e.target.value, 10) / 100);
  }
});

// Dots
document.getElementById('dotsToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadDotsLayer();
  else removeLayer('dots');
});
document.getElementById('dotSize').addEventListener('input', (e) => {
  document.getElementById('dotSizeLabel').textContent = e.target.value;
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-radius', parseFloat(e.target.value));
  }
  updateLegend();
});
document.getElementById('dotsOpacity').addEventListener('input', (e) => {
  document.getElementById('dotsOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-opacity', parseInt(e.target.value, 10) / 100);
  }
});

// Boundaries
document.getElementById('boundariesToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadBoundariesLayer();
  else removeLayer('boundaries');
});
document.getElementById('boundariesOpacity').addEventListener('input', (e) => {
  document.getElementById('boundariesOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.boundaries.layerId)) {
    map.setPaintProperty(layerDefinitions.boundaries.layerId, 'line-opacity', parseInt(e.target.value, 10) / 100);
  }
});

// Basemap switcher
document.getElementById('basemapSelect').addEventListener('change', (e) => {
  const style = e.target.value;
  const enabledSnapshot = { ...enabledLayers };
  map.setStyle(style);

  map.once('styledata', () => {
    addBaseControls();

    // Re-add enabled layers after style reset
    for (const key in enabledSnapshot) {
      if (!enabledSnapshot[key]) continue;
      if (key === 'popdens') { if (popdensData) applyPopDensClassification(); else loadPopDensLayer(); }
      else if (key === 'denscover') { if (denscoverData) applyDensCoverCategorical(); else loadDensCoverLayer(); }
      else if (key === 'poipop') loadPoipopLayer();
      else if (key === 'contours') loadContoursLayer();
      else if (key === 'dots') loadDotsLayer();
      else if (key === 'boundaries') loadBoundariesLayer();
    }
  });
});

showHideControls();

['popdensToggle','denscoverToggle','poipopToggle','contoursToggle','dotsToggle','boundariesToggle'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    showHideControls();
    updateLegend();
  });
});

console.log('Thessalia Cartography Viewer - Ready');
</script>

</body>
</html>




