<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Thessalia Cartography ‚Äì Interactive Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<!-- ‚úÖ Proj4 Œ≥ŒπŒ± auto ŒºŒµœÑŒ±œÑœÅŒøœÄŒÆ ŒïŒìŒ£Œë87 -> WGS84 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

<style>
  body { margin: 0; padding: 0; font-family: Arial, Helvetica, sans-serif; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }

  #styleSelector {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 6px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.25);
  }

  #controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 10px;
    font-size: 13px;
    border-radius: 6px;
    width: 300px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  }
  .layer-controls { margin-top:6px; padding:8px; background:#fafafa; border-radius:4px; display:none; }
  .layer-controls label { display:block; font-size:12px; margin-top:6px; }
  .layer-controls input[type="range"], .layer-controls select { width:100%; margin-top:4px; }

  #legend {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 6;
    background: white;
    padding: 18px;
    font-size: 13px;
    border-radius: 6px;
    max-width: 360px;
    max-height: 85vh;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    display: none;
    resize: both;
    overflow: auto;
    min-width: 200px;
    min-height: 100px;
  }

  .legend-header {
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #333;
  }
  .legend-map-title {
    font-size: 15px;
    font-weight: 700;
    color: #000;
    margin-bottom: 10px;
    line-height: 1.4;
    text-align: center;
  }
  .legend-author {
    font-size: 10px;
    color: #555;
    line-height: 1.4;
    text-align: left;
  }
  .legend-author strong { font-weight: 700; }

  .legend-row { display:flex; align-items:center; margin-bottom:8px; }
  .legend-color { width:20px; height:20px; margin-right:8px; border-radius:3px; flex:none; border: 1px solid rgba(0,0,0,0.15); }
  .legend-line { width:40px; height:14px; margin-right:8px; flex:none; }
  .legend-title { font-weight:700; margin-bottom:8px; display:block; }
  .control-value { font-weight:700; margin-left:6px; color:#333; }
  hr { border: none; border-top: 1px solid #eee; margin:8px 0; }
</style>
</head>

<body>

<div id="styleSelector">
  <select id="basemapSelect">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark</option>
  </select>
</div>

<div id="controls">
  <strong>Layers</strong><br><br>

  <input type="checkbox" id="popdensToggle"> <strong>Population Density (Choropleth Map)</strong><br>
  <div class="layer-controls" id="popdensControls">
    <label>Classification method:
      <select id="classificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
        <option value="custom">Custom intervals</option>
      </select>
    </label>
    <label id="numClassesLabel">Number of classes:
      <select id="numClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="popdensOpacityLabel" class="control-value">60%</span>
      <input type="range" id="popdensOpacity" min="0" max="100" value="60">
    </label>
  </div>
  <hr>

  <input type="checkbox" id="denscoverToggle"> <strong>Population Density / Land cover (Dasymmetric)</strong><br>
  <div class="layer-controls" id="denscoverControls">
    <label>Classification method:
      <select id="denscoverClassificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
        <option value="custom">Custom intervals</option>
      </select>
    </label>
    <label id="denscoverNumClassesLabel">Number of classes:
      <select id="denscoverNumClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="denscoverOpacityLabel" class="control-value">60%</span>
      <input type="range" id="denscoverOpacity" min="0" max="100" value="60">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      ŒëŒΩ Œ¥ŒµŒΩ œÖœÄŒ¨œÅœáŒµŒπ œÄŒµŒ¥ŒØŒø DENS_COVER, Œ∏Œ± ŒµŒºœÜŒ±ŒΩŒπœÉœÑŒµŒØ Œ∫Œ±œÑŒ∑Œ≥ŒøœÅŒπŒøœÄŒøŒØŒ∑œÉŒ∑ land cover (COVER_CODE).
    </small>
  </div>
  <hr>

  <input type="checkbox" id="poipopToggle"> <strong>Population (Proportional symbols)</strong><br>
  <div class="layer-controls" id="poipopControls">
    <label>Maximum circle radius (px): <span id="maxRadiusLabel" class="control-value">100</span>
      <input type="range" id="maxRadius" min="20" max="200" value="100">
    </label>
    <label>Opacity (circles): <span id="poipopOpacityLabel" class="control-value">25%</span>
      <input type="range" id="poipopOpacity" min="0" max="100" value="25">
    </label>
  </div>
  <hr>

  <input type="checkbox" id="contoursToggle"> <strong>Population dynamic (Isopleths map)</strong><br>
  <div class="layer-controls" id="contoursControls">
    <label>Opacity (contours): <span id="contoursOpacityLabel" class="control-value">80%</span>
      <input type="range" id="contoursOpacity" min="0" max="100" value="80">
    </label>
  </div>
  <hr>

  <input type="checkbox" id="dotsToggle"> <strong>Population (Dot map)</strong><br>
  <div class="layer-controls" id="dotsControls">
    <label>Dot size (px): <span id="dotSizeLabel" class="control-value">1.9</span>
      <input type="range" id="dotSize" min="0.5" max="6" step="0.1" value="1.9">
    </label>
    <label>Opacity (dots): <span id="dotsOpacityLabel" class="control-value">100%</span>
      <input type="range" id="dotsOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <input type="checkbox" id="boundariesToggle"> <strong>Municipal boundaries</strong><br>
  <div class="layer-controls" id="boundariesControls">
    <label>Opacity (boundaries): <span id="boundariesOpacityLabel" class="control-value">100%</span>
      <input type="range" id="boundariesOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <div style="font-size:12px;color:#555">
    <strong>Data notes</strong><br>
    - GeoJSONs in <code>data/</code><br>
    - Œ†œÅŒøœÉŒøœáŒÆ: ŒëŒΩ Œ∫Œ¨œÄŒøŒπŒ± ŒµŒØŒΩŒ±Œπ œÉŒµ ŒïŒìŒ£Œë87, Œ≥ŒØŒΩŒµœÑŒ±Œπ auto ŒºŒµœÑŒ±œÑœÅŒøœÄŒÆ.<br>
  </div>
</div>

<div id="legend"></div>
<div id="map"></div>

<script>
// ============================================================
// 0. PROJ4 defs: EGSA87 (EPSG:2100) -> WGS84 (EPSG:4326)
// ============================================================
proj4.defs("EPSG:2100","+proj=tmerc +lat_0=0 +lon_0=24 +k=0.9996 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
proj4.defs("EPSG:4326","+proj=longlat +datum=WGS84 +no_defs");

// ============================================================
// 1. MAP INITIALIZATION
// ============================================================
const map = new maplibregl.Map({
  container: 'map',
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  center: [22.45, 39.45],
  zoom: 8.2
});
map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right');
map.addControl(new maplibregl.ScaleControl({ maxWidth: 120, unit: 'metric' }), 'bottom-left');

// ============================================================
// 2. DATA CONFIGURATION
// ============================================================
const layerDefinitions = {
  popdens: {
    sourceId: 'popdens-src',
    layerId: 'popdens-layer',
    url: 'data/dens.geojson',
    dataField: 'POPDENS' // Œ∏Œ± Œ≥ŒØŒΩŒµŒπ auto-detect Œ±ŒΩ Œ¥ŒµŒΩ œÖœÄŒ¨œÅœáŒµŒπ
  },
  denscover: {
    sourceId: 'denscover-src',
    layerId: 'denscover-layer',
    url: 'data/dasimetriko.geojson',
    dataField: 'DENS_COVER' // Œ±ŒΩ Œ¥ŒµŒΩ œÖœÄŒ¨œÅœáŒµŒπ, Œ∏Œ± œÄŒ¨ŒµŒπ œÉŒµ COVER_CODE categories
  },
  poipop: {
    sourceId: 'poipop-src',
    layerId: 'poipop-layer',
    url: 'data/dimoipop91_21.geojson',
    dataField: 'POPMUN',
    maxValueApprox: 150000
  },
  contours: {
    sourceId: 'contours-src',
    layerId: 'contours-layer',
    url: 'data/kur_deut.geojson'
  },
  dots: {
    sourceId: 'dots-src',
    layerId: 'dots-layer',
    url: 'data/dot500pop.geojson'
  },
  boundaries: {
    sourceId: 'boundaries-src',
    layerId: 'boundaries-layer',
    url: 'data/dimoi_oria.geojson'
  }
};

let popdensData = null;
let denscoverData = null;

const enabledLayers = {
  popdens: false,
  denscover: false,
  poipop: false,
  contours: false,
  dots: false,
  boundaries: false
};

// ============================================================
// Helpers: bbox + detect CRS + reproject
// ============================================================
function walkCoords(coords, cb){
  if (typeof coords[0] === 'number') return cb(coords);
  for (const c of coords) walkCoords(c, cb);
}
function getFirstCoord(geojson){
  let found = null;
  walkCoords(geojson.features[0].geometry.coordinates, (xy) => { if(!found) found = xy; });
  return found;
}
function seemsProjectedXY(xy){
  if (!xy) return false;
  const [x,y]=xy;
  // lon/lat ranges: |lon|<=180, |lat|<=90
  return (Math.abs(x) > 200 || Math.abs(y) > 100);
}
function reprojectGeoJSON_EGSA87_to_WGS84(gj){
  const out = JSON.parse(JSON.stringify(gj));
  for (const f of out.features){
    walkCoords(f.geometry.coordinates, (xy) => {
      const [x,y] = xy;
      const ll = proj4("EPSG:2100","EPSG:4326",[x,y]);
      xy[0]=ll[0]; xy[1]=ll[1];
    });
  }
  // Œ∫Œ±Œ∏Œ¨œÅŒπœÉŒµ crs
  delete out.crs;
  return out;
}
function fitToGeoJSON(gj){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for (const f of gj.features){
    walkCoords(f.geometry.coordinates, ([x,y])=>{
      if (x<minX) minX=x;
      if (y<minY) minY=y;
      if (x>maxX) maxX=x;
      if (y>maxY) maxY=y;
    });
  }
  if (isFinite(minX)) {
    map.fitBounds([[minX,minY],[maxX,maxY]], { padding: 40, duration: 800 });
  }
}

function listFields(gj){
  const p = gj.features?.[0]?.properties || {};
  return Object.keys(p);
}
function pickNumericField(gj, preferredList=[]){
  const fields = listFields(gj);
  for (const k of preferredList){
    if (fields.includes(k)) return k;
  }
  // Œ≤œÅŒµœÇ œÄœÅœéœÑŒø numeric œÄŒµŒ¥ŒØŒø
  for (const k of fields){
    const v = gj.features[0].properties[k];
    const n = parseFloat(v);
    if (v !== null && v !== undefined && !Number.isNaN(n) && Number.isFinite(n)) return k;
  }
  return null;
}

async function fetchGeoJSONSmart(url){
  const r = await fetch(url);
  const gj = await r.json();

  // auto reproject Œ±ŒΩ ŒºŒøŒπŒ¨Œ∂ŒµŒπ ŒïŒìŒ£Œë87
  const first = getFirstCoord(gj);
  if (seemsProjectedXY(first)){
    console.warn("Detected projected coords (likely EGSA87). Reprojecting:", url, first);
    return reprojectGeoJSON_EGSA87_to_WGS84(gj);
  }
  return gj;
}

function ensureSource(id, urlOrGeojson) {
  if (!map.getSource(id)) {
    map.addSource(id, { type: 'geojson', data: urlOrGeojson });
  } else {
    if (typeof urlOrGeojson === 'object') map.getSource(id).setData(urlOrGeojson);
  }
}

// ============================================================
// 3. Color schemes
// ============================================================
const colorSchemes = {
  3: ['#ffcccc', '#ff6666', '#990000'],
  4: ['#ffcccc', '#ff9999', '#cc0000', '#990000'],
  5: ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000'],
  6: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#cc0000', '#990000'],
  7: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#ff0000', '#cc0000', '#990000']
};
const denscoverColorSchemes = colorSchemes;

const customBreaks = [30, 75, 150, 300, 600];
const customColors = ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000', '#660000'];

const denscoverCustomBreaks = [500, 1500, 3500, 6000, 8500];
const denscoverCustomColors = ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000', '#660000'];

// ============================================================
// 4. Classification
// ============================================================
function equalIntervalBreaks(sorted, n) {
  const min = sorted[0];
  const max = sorted[sorted.length - 1];
  if (min === max) return [max];
  const step = (max - min) / n;
  const breaks = [];
  for (let i = 1; i < n; i++) breaks.push(min + step * i);
  return breaks.map(b => Number(b.toFixed(2)));
}
function quantileBreaks(sorted, n) {
  const breaks = [];
  for (let i = 1; i < n; i++) {
    const idx = Math.floor((sorted.length * i) / n);
    breaks.push(sorted[Math.min(idx, sorted.length - 1)]);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}
function jenksBreaks(sorted, numClasses) {
  const n = sorted.length;
  const mat1 = Array.from({ length: n + 1 }, () => Array(numClasses + 1).fill(0));
  const mat2 = Array.from({ length: n + 1 }, () => Array(numClasses + 1).fill(0));

  for (let i = 1; i <= numClasses; i++) {
    mat1[1][i] = 1;
    mat2[1][i] = 0;
    for (let j = 2; j <= n; j++) mat2[j][i] = Infinity;
  }

  for (let l = 2; l <= n; l++) {
    let s1 = 0, s2 = 0, w = 0;
    for (let m = 1; m <= l; m++) {
      const i3 = l - m + 1;
      const val = sorted[i3 - 1];
      s2 += val * val;
      s1 += val;
      w++;
      const v = s2 - (s1 * s1) / w;
      const i4 = i3 - 1;
      if (i4 !== 0) {
        for (let j = 2; j <= numClasses; j++) {
          if (mat2[l][j] >= (v + mat2[i4][j - 1])) {
            mat1[l][j] = i3;
            mat2[l][j] = v + mat2[i4][j - 1];
          }
        }
      }
    }
    mat1[l][1] = 1;
    mat2[l][1] = mat2[l - 1][1] + (sorted[l - 1] - sorted[0]) * (sorted[l - 1] - sorted[0]);
  }

  const breaks = [];
  let k = n;
  for (let j = numClasses; j >= 2; j--) {
    const id = mat1[k][j] - 1;
    breaks.push(sorted[id]);
    k = mat1[k][j] - 1;
  }
  return breaks.reverse().map(b => Number(b.toFixed(2)));
}
function calculateBreaks(values, numClasses, method, customBreaksArray) {
  const sorted = values.filter(v => v != null && !isNaN(v)).sort((a, b) => a - b);
  if (sorted.length === 0) return [];
  if (method === 'equal') return equalIntervalBreaks(sorted, numClasses);
  if (method === 'quantile') return quantileBreaks(sorted, numClasses);
  if (method === 'natural') return jenksBreaks(sorted, numClasses);
  if (method === 'custom') return customBreaksArray;
  return equalIntervalBreaks(sorted, numClasses);
}
function createStepExpression(breaks, colors, field) {
  const expr = ['step', ['to-number', ['get', field]], colors[0]];
  for (let i = 0; i < breaks.length; i++) {
    expr.push(breaks[i]);
    expr.push(colors[i + 1] || colors[colors.length - 1]);
  }
  return expr;
}

// ============================================================
// 5. LAYERS
// ============================================================

function safeAlertMissingField(layerName, wantedField, gj){
  const fields = listFields(gj);
  alert(`‚ö†Ô∏è ŒîŒµŒΩ Œ≤œÅŒ≠Œ∏Œ∑Œ∫Œµ Œ±œÅŒπŒ∏ŒºŒ∑œÑŒπŒ∫œå œÄŒµŒ¥ŒØŒø Œ≥ŒπŒ± œÑŒ±ŒæŒπŒΩœåŒºŒ∑œÉŒ∑.\nLayer: ${layerName}\nŒñŒ∑œÑŒøœçŒºŒµŒΩŒø: "${wantedField}"\nŒîŒπŒ±Œ∏Œ≠œÉŒπŒºŒ± œÄŒµŒ¥ŒØŒ±:\n${fields.join(", ")}`);
}

function applyPopDensClassification() {
  if (!popdensData) return;

  // auto-detect field Œ±ŒΩ ŒªŒµŒØœÄŒµŒπ POPDENS
  const detected = pickNumericField(popdensData, ['POPDENS','DENS','DENSITY','POP_DENS','popdens']);
  if (!detected){
    safeAlertMissingField("popdens", layerDefinitions.popdens.dataField, popdensData);
    return;
  }
  layerDefinitions.popdens.dataField = detected;

  const method = document.getElementById('classificationMethod').value;
  const nclasses = parseInt(document.getElementById('numClasses').value, 10);

  let colors, breaks;
  if (method === 'custom') {
    breaks = customBreaks;
    colors = customColors;
  } else {
    colors = colorSchemes[nclasses] || colorSchemes[5];
    const values = popdensData.features.map(f => parseFloat(f.properties[layerDefinitions.popdens.dataField]));
    breaks = calculateBreaks(values, nclasses, method, null);
  }

  if (!breaks.length){
    safeAlertMissingField("popdens", layerDefinitions.popdens.dataField, popdensData);
    return;
  }

  const expr = createStepExpression(breaks, colors, layerDefinitions.popdens.dataField);
  ensureSource(layerDefinitions.popdens.sourceId, popdensData);

  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.popdens.layerId,
      type: 'fill',
      source: layerDefinitions.popdens.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('popdensOpacity').value, 10) / 100
      }
    });
  }

  layerDefinitions.popdens.breaks = breaks;
  layerDefinitions.popdens.colors = colors;
  enabledLayers.popdens = true;
  document.getElementById('popdensControls').style.display = 'block';
  updateLegend();
}

async function loadPopDensLayer() {
  try {
    popdensData = await fetchGeoJSONSmart(layerDefinitions.popdens.url);
    applyPopDensClassification();
    // fit Œ±ŒΩ ŒµŒØŒΩŒ±Œπ œÑŒø œÄœÅœéœÑŒø layer œÄŒøœÖ Œ±ŒΩŒøŒØŒ≥ŒµŒπœÇ
    fitToGeoJSON(popdensData);
  } catch (err) {
    console.error(err);
    alert('Error loading data/dens.geojson');
  }
}

// ---- denscover: Œ±ŒΩ Œ≠œáŒµŒπ DENS_COVER => numeric choropleth, Œ±ŒªŒªŒπœéœÇ categories COVER_CODE
let denscoverIsCategorical = false;

function applyDensCoverClassification() {
  if (!denscoverData) return;

  const numericField = pickNumericField(denscoverData, ['DENS_COVER','DENS','DENSITY']);
  denscoverIsCategorical = !numericField;

  if (!denscoverIsCategorical){
    layerDefinitions.denscover.dataField = numericField;

    const method = document.getElementById('denscoverClassificationMethod').value;
    const nclasses = parseInt(document.getElementById('denscoverNumClasses').value, 10);

    let colors, breaks;
    if (method === 'custom') {
      breaks = denscoverCustomBreaks;
      colors = denscoverCustomColors;
    } else {
      colors = denscoverColorSchemes[nclasses] || denscoverColorSchemes[5];
      const values = denscoverData.features.map(f => parseFloat(f.properties[layerDefinitions.denscover.dataField]));
      breaks = calculateBreaks(values, nclasses, method, null);
    }

    if (!breaks.length){
      safeAlertMissingField("denscover", layerDefinitions.denscover.dataField, denscoverData);
      return;
    }

    const expr = createStepExpression(breaks, colors, layerDefinitions.denscover.dataField);
    ensureSource(layerDefinitions.denscover.sourceId, denscoverData);

    if (map.getLayer(layerDefinitions.denscover.layerId)) {
      map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-color', expr);
    } else {
      // Œ≤Œ¨ŒªŒµ œÑŒø œÄŒ¨ŒΩœâ Œ±œÄœå popdens Œ±ŒΩ œÖœÄŒ¨œÅœáŒµŒπ
      const beforeId = map.getLayer(layerDefinitions.poipop.layerId) ? layerDefinitions.poipop.layerId : undefined;
      map.addLayer({
        id: layerDefinitions.denscover.layerId,
        type: 'fill',
        source: layerDefinitions.denscover.sourceId,
        paint: {
          'fill-color': expr,
          'fill-opacity': parseInt(document.getElementById('denscoverOpacity').value, 10) / 100
        }
      }, beforeId);
    }

    layerDefinitions.denscover.breaks = breaks;
    layerDefinitions.denscover.colors = colors;
  } else {
    // categorical cover
    const fields = listFields(denscoverData);
    const codeField = fields.includes('COVER_CODE') ? 'COVER_CODE' : fields[0];

    const uniq = new Set();
    for (const f of denscoverData.features){
      const v = f.properties?.[codeField];
      if (v !== undefined && v !== null) uniq.add(String(v));
    }
    const values = Array.from(uniq).sort();

    // palette
    const palette = ['#fef0d9','#fdcc8a','#fc8d59','#e34a33','#b30000','#8856a7','#2ca25f','#3182bd','#756bb1','#31a354'];
    const matchExpr = ['match', ['to-string', ['get', codeField]]];
    values.forEach((v,i)=>{ matchExpr.push(v); matchExpr.push(palette[i % palette.length]); });
    matchExpr.push('#cccccc');

    ensureSource(layerDefinitions.denscover.sourceId, denscoverData);

    if (!map.getLayer(layerDefinitions.denscover.layerId)) {
      map.addLayer({
        id: layerDefinitions.denscover.layerId,
        type: 'fill',
        source: layerDefinitions.denscover.sourceId,
        paint: {
          'fill-color': matchExpr,
          'fill-opacity': parseInt(document.getElementById('denscoverOpacity').value, 10) / 100
        }
      });
    } else {
      map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-color', matchExpr);
    }

    layerDefinitions.denscover.categorical = { field: codeField, values, palette };
    delete layerDefinitions.denscover.breaks;
    delete layerDefinitions.denscover.colors;
  }

  enabledLayers.denscover = true;
  document.getElementById('denscoverControls').style.display = 'block';
  updateLegend();
}

async function loadDensCoverLayer() {
  try {
    denscoverData = await fetchGeoJSONSmart(layerDefinitions.denscover.url);
    applyDensCoverClassification();
    fitToGeoJSON(denscoverData);
  } catch (err) {
    console.error(err);
    alert('Error loading data/dasimetriko.geojson');
  }
}

async function loadPoipopLayer() {
  const def = layerDefinitions.poipop;
  try {
    const geojson = await fetchGeoJSONSmart(def.url);

    geojson.features.sort((a, b) => {
      const valA = parseFloat(a.properties?.[def.dataField]) || 0;
      const valB = parseFloat(b.properties?.[def.dataField]) || 0;
      return valB - valA;
    });

    ensureSource(def.sourceId, geojson);

    const maxR = parseInt(document.getElementById('maxRadius').value, 10);
    const vL = def.maxValueApprox || 150000;
    const radiusExpr = ['*', ['^', ['/', ['to-number', ['get', def.dataField]], vL], 0.57], maxR];

    if (!map.getLayer(def.layerId)) {
      map.addLayer({
        id: def.layerId,
        type: 'circle',
        source: def.sourceId,
        paint: {
          'circle-color': 'rgba(255,0,0,0.25)',
          'circle-radius': radiusExpr,
          'circle-opacity': parseInt(document.getElementById('poipopOpacity').value, 10) / 100,
          'circle-stroke-color': 'red',
          'circle-stroke-width': 0.8
        }
      });
    } else {
      map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
      map.setPaintProperty(def.layerId, 'circle-opacity', parseInt(document.getElementById('poipopOpacity').value, 10) / 100);
    }

    enabledLayers.poipop = true;
    document.getElementById('poipopControls').style.display = 'block';
    updateLegend();
    fitToGeoJSON(geojson);
  } catch (err) {
    console.error(err);
    alert('Error loading proportional symbols geojson.');
  }
}

function updatePoipopRadius() {
  const def = layerDefinitions.poipop;
  if (!map.getLayer(def.layerId)) return;

  const maxR = parseInt(document.getElementById('maxRadius').value, 10);
  const vL = def.maxValueApprox || 150000;
  const radiusExpr = ['*', ['^', ['/', ['to-number', ['get', def.dataField]], vL], 0.57], maxR];

  map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
  updateLegend();
}

async function loadContoursLayer() {
  const def = layerDefinitions.contours;
  try {
    const gj = await fetchGeoJSONSmart(def.url);
    ensureSource(def.sourceId, gj);

    const widthExpr = ['case', ['==', ['to-number', ['get', 'ID']], 1], 3, 1.2];
    const color = '#8B0000';

    if (!map.getLayer(def.layerId)) {
      map.addLayer({
        id: def.layerId,
        type: 'line',
        source: def.sourceId,
        paint: {
          'line-color': color,
          'line-width': widthExpr,
          'line-opacity': parseInt(document.getElementById('contoursOpacity').value, 10) / 100
        }
      });
    } else {
      map.setPaintProperty(def.layerId, 'line-width', widthExpr);
      map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('contoursOpacity').value, 10) / 100);
    }

    enabledLayers.contours = true;
    document.getElementById('contoursControls').style.display = 'block';
    updateLegend();
    fitToGeoJSON(gj);
  } catch (err) {
    console.error(err);
    alert('Error loading contours geojson.');
  }
}

async function loadDotsLayer() {
  const def = layerDefinitions.dots;
  try {
    const gj = await fetchGeoJSONSmart(def.url);
    ensureSource(def.sourceId, gj);

    const dotSize = parseFloat(document.getElementById('dotSize').value);
    const opacity = parseInt(document.getElementById('dotsOpacity').value, 10) / 100;

    if (!map.getLayer(def.layerId)) {
      map.addLayer({
        id: def.layerId,
        type: 'circle',
        source: def.sourceId,
        paint: {
          'circle-color': '#ff0000',
          'circle-radius': dotSize,
          'circle-opacity': opacity
        }
      });
    } else {
      map.setPaintProperty(def.layerId, 'circle-radius', dotSize);
      map.setPaintProperty(def.layerId, 'circle-opacity', opacity);
    }

    enabledLayers.dots = true;
    document.getElementById('dotsControls').style.display = 'block';
    updateLegend();
    fitToGeoJSON(gj);
  } catch (err) {
    console.error(err);
    alert('Error loading dot density geojson.');
  }
}

async function loadBoundariesLayer() {
  const def = layerDefinitions.boundaries;
  try {
    const gj = await fetchGeoJSONSmart(def.url);
    ensureSource(def.sourceId, gj);

    if (!map.getLayer(def.layerId)) {
      // boundaries œÄŒ¨ŒΩœâ-œÄŒ¨ŒΩœâ
      map.addLayer({
        id: def.layerId,
        type: 'line',
        source: def.sourceId,
        paint: {
          'line-color': '#bbbbbb',
          'line-width': 1,
          'line-opacity': parseInt(document.getElementById('boundariesOpacity').value, 10) / 100
        }
      });
    } else {
      map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('boundariesOpacity').value, 10) / 100);
    }

    enabledLayers.boundaries = true;
    document.getElementById('boundariesControls').style.display = 'block';
    updateLegend();
    fitToGeoJSON(gj);
  } catch (err) {
    console.error(err);
    alert('Error loading boundaries geojson.');
  }
}

function removeLayer(name) {
  const def = layerDefinitions[name];
  if (map.getLayer(def.layerId)) map.removeLayer(def.layerId);
  if (map.getSource(def.sourceId)) map.removeSource(def.sourceId);
  enabledLayers[name] = false;
  const c = document.getElementById(name + 'Controls');
  if (c) c.style.display = 'none';
  updateLegend();
}

// ============================================================
// 6. LEGEND
// ============================================================
function updateLegend() {
  const legend = document.getElementById('legend');
  let html = '';

  html += `
    <div class="legend-header">
      <div class="legend-map-title">THESSALIA POPULATION (Census 2021)</div>
      <div class="legend-author">
        <strong>Data source:</strong> Hellenic Statistical Authority (ELSTAT) ‚Äì Census 2021<br>
        <strong>Produced by:</strong> Œ£Œ§ŒëŒúŒëŒ§ŒïŒõŒë ŒôŒ¶ŒôŒìŒïŒùŒïŒôŒë Œ†ŒüŒ•ŒõŒôŒëŒ£Œó<br>
        <strong>Student ID:</strong> rs21636<br>
        National Technical University of Athens (NTUA)<br>
        School of Rural, Surveying & Geoinformatics Engineering<br>
        Cartography Laboratory<br>
        Thematic Cartography, Academic Year 2025-2026
      </div>
    </div>
  `;

  if (enabledLayers.popdens && layerDefinitions.popdens.breaks) {
    const breaks = layerDefinitions.popdens.breaks;
    const colors = layerDefinitions.popdens.colors;
    html += `<div class="legend-title">Choropleth map (people / km¬≤)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    for (let i = 0; i < breaks.length - 1; i++) {
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i + 1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i + 1]}</div></div>`;
    }
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length - 1]}"></div><div>&gt; ${breaks[breaks.length - 1]}</div></div>`;
    html += '<hr>';
  }

  if (enabledLayers.denscover) {
    if (!denscoverIsCategorical && layerDefinitions.denscover.breaks) {
      const breaks = layerDefinitions.denscover.breaks;
      const colors = layerDefinitions.denscover.colors;
      html += `<div class="legend-title">Dasymmetric (people / km¬≤)</div>`;
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
      for (let i = 0; i < breaks.length - 1; i++) {
        html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i + 1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i + 1]}</div></div>`;
      }
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length - 1]}"></div><div>&gt; ${breaks[breaks.length - 1]}</div></div>`;
      html += '<hr>';
    } else if (layerDefinitions.denscover.categorical) {
      const { field, values, palette } = layerDefinitions.denscover.categorical;
      html += `<div class="legend-title">Land cover (${field})</div>`;
      values.slice(0,10).forEach((v,i)=>{
        html += `<div class="legend-row"><div class="legend-color" style="background:${palette[i % palette.length]}"></div><div>${v}</div></div>`;
      });
      if (values.length > 10) html += `<div style="font-size:11px;color:#666">(+ ${values.length-10} more)</div>`;
      html += '<hr>';
    }
  }

  if (enabledLayers.poipop) {
    html += `<div class="legend-title">Population (proportional symbols)</div>`;
    html += `<div style="font-size:11px;color:#666">ŒöœåŒ∫Œ∫ŒπŒΩŒøŒπ Œ∫œçŒ∫ŒªŒøŒπ = POPMUN</div><hr>`;
  }

  if (enabledLayers.contours) {
    html += `<div class="legend-title">Population dynamic (isopleths)</div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="3"/></svg><div>Primary (ID=1)</div></div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="1.2"/></svg><div>Secondary (ID=2)</div></div>`;
    html += '<hr>';
  }

  if (enabledLayers.dots) {
    html += `<div class="legend-title">Dot density</div>`;
    html += `<div class="legend-row"><svg width="30" height="24"><circle cx="15" cy="12" r="${parseFloat(document.getElementById('dotSize').value)}" fill="#ff0000"/></svg><div>1 dot = 500 people</div></div>`;
    html += '<hr>';
  }

  if (enabledLayers.boundaries) {
    html += `<div class="legend-row"><svg width="40" height="18"><line x1="0" y1="9" x2="40" y2="9" stroke="#bbbbbb" stroke-width="1"/></svg> <div>Municipal boundaries</div></div>`;
  }

  if (html.length) {
    html += `<div style="text-align:right;font-size:10px;color:#999;margin-top:10px;">üí° Drag corner to resize</div>`;
    legend.innerHTML = html;
    legend.style.display = 'block';
  } else {
    legend.style.display = 'none';
  }
}

// ============================================================
// 7. EVENT LISTENERS
// ============================================================
function showHideControls() {
  Object.keys(enabledLayers).forEach(k => {
    const checkbox = document.getElementById(k + 'Toggle');
    const controls = document.getElementById(k + 'Controls');
    if (!controls) return;
    controls.style.display = checkbox.checked ? 'block' : 'none';
  });
}

document.getElementById('popdensToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadPopDensLayer(); else removeLayer('popdens');
});

document.getElementById('classificationMethod').addEventListener('change', () => {
  const method = document.getElementById('classificationMethod').value;
  const numClassesLabel = document.getElementById('numClassesLabel');
  const numClassesSelect = document.getElementById('numClasses');
  if (method === 'custom') { numClassesSelect.disabled = true; numClassesLabel.style.opacity = '0.5'; }
  else { numClassesSelect.disabled = false; numClassesLabel.style.opacity = '1'; }
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('numClasses').addEventListener('change', () => {
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('popdensOpacity').addEventListener('input', (e) => {
  document.getElementById('popdensOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-opacity', parseInt(e.target.value, 10) / 100);
  }
});

document.getElementById('denscoverToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadDensCoverLayer(); else removeLayer('denscover');
});

document.getElementById('denscoverClassificationMethod').addEventListener('change', () => {
  if (enabledLayers.denscover) applyDensCoverClassification();
});
document.getElementById('denscoverNumClasses').addEventListener('change', () => {
  if (enabledLayers.denscover) applyDensCoverClassification();
});

document.getElementById('denscoverOpacity').addEventListener('input', (e) => {
  document.getElementById('denscoverOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-opacity', parseInt(e.target.value, 10) / 100);
  }
});

document.getElementById('poipopToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadPoipopLayer(); else removeLayer('poipop');
});

document.getElementById('maxRadius').addEventListener('input', (e) => {
  document.getElementById('maxRadiusLabel').textContent = e.target.value;
  updatePoipopRadius();
});

document.getElementById('poipopOpacity').addEventListener('input', (e) => {
  document.getElementById('poipopOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.poipop.layerId)) {
    map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-opacity', parseInt(e.target.value, 10) / 100);
  }
});

document.getElementById('contoursToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadContoursLayer(); else removeLayer('contours');
});

document.getElementById('contoursOpacity').addEventListener('input', (e) => {
  document.getElementById('contoursOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.contours.layerId)) {
    map.setPaintProperty(layerDefinitions.contours.layerId, 'line-opacity', parseInt(e.target.value, 10) / 100);
  }
});

document.getElementById('dotsToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadDotsLayer(); else removeLayer('dots');
});

document.getElementById('dotSize').addEventListener('input', (e) => {
  document.getElementById('dotSizeLabel').textContent = e.target.value;
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-radius', parseFloat(e.target.value));
  }
});

document.getElementById('dotsOpacity').addEventListener('input', (e) => {
  document.getElementById('dotsOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-opacity', parseInt(e.target.value, 10) / 100);
  }
});

document.getElementById('boundariesToggle').addEventListener('change', (e) => {
  if (e.target.checked) loadBoundariesLayer(); else removeLayer('boundaries');
});

document.getElementById('boundariesOpacity').addEventListener('input', (e) => {
  document.getElementById('boundariesOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.boundaries.layerId)) {
    map.setPaintProperty(layerDefinitions.boundaries.layerId, 'line-opacity', parseInt(e.target.value, 10) / 100);
  }
});

document.getElementById('basemapSelect').addEventListener('change', (e) => {
  const style = e.target.value;
  const enabledSnapshot = { ...enabledLayers };
  map.setStyle(style);

  map.once('styledata', () => {
    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right');
    map.addControl(new maplibregl.ScaleControl({ maxWidth: 120, unit: 'metric' }), 'bottom-left');

    for (const key in enabledSnapshot) {
      if (!enabledSnapshot[key]) continue;
      if (key === 'popdens') { if (popdensData) applyPopDensClassification(); else loadPopDensLayer(); }
      else if (key === 'denscover') { if (denscoverData) applyDensCoverClassification(); else loadDensCoverLayer(); }
      else if (key === 'poipop') loadPoipopLayer();
      else if (key === 'contours') loadContoursLayer();
      else if (key === 'dots') loadDotsLayer();
      else if (key === 'boundaries') loadBoundariesLayer();
    }
  });
});

showHideControls();
console.log('Thessalia Cartography Viewer - Ready');
</script>

</body>
</html>



